<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTS Frontend</title>
    <script>
      // This value will be replaced by the environment/build process at deploy time.
      window.ttsConfig = {
        ORCHESTRATOR_WORKER_URL: '{{ORCHESTRATOR_WORKER_URL_ACTUAL_VALUE}}'
      };
    </script>
  <style>
    /* MODIFICATION: Global reset and body styling for fixed header */
    body {
      font-family: Arial, sans-serif;
      /* display: flex; /* Removed for normal flow with fixed header */
      /* justify-content: center; */
      /* align-items: center; */
      /* min-height: 100vh; */
      background-color: #f4f4f4;
      margin: 0;
      padding-top: 230px;
      /* MODIFICATION: Add padding to body to offset fixed input bar height */
      /* This will be dynamically updated by JavaScript */
    }

    /* MODIFICATION: Style for the fixed input bar */
    .top-input-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #ffffff;
      padding: 15px 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      box-sizing: border-box;
    }

    .top-input-bar .input-group {
      /* MODIFICATION: For better layout within the bar */
      margin: 0 auto;
      /* Center the group */
      text-align: center;
    }

    .container {
      /* MODIFICATION: Container is no longer the main centering/positioning element for inputs */
      /* position: relative; /* Kept for cog icon positioning */
      display: flex;
      flex-direction: column;
      /* Added for better stacking of internal elements */
      align-items: center;
      /* Center items like download button, message */
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      width: 90%;
      max-width: 700px;
      /* Added for better responsiveness on large screens */
      text-align: center;
      margin: 20px auto;
      /* Centering the content box below the input bar */
      position: relative;
      /* For cog positioning inside this specific box if preferred */
    }

    /* MODIFICATION: Relative positioning for cog icon placement */
    /* Let's position cog relative to the main container, below the input bar */
    #settingsCog {
      position: fixed;
      /* Change to fixed positioning relative to viewport */
      top: 15px;
      right: 15px;
      cursor: pointer;
      font-size: 20px;
      /* Adjust size as needed */
      color: #555;
      display: inline-block;
      /* Changed from none to inline-block to ensure rendering */
      /* Hidden by default, shown by JS if API key is set */
    }

    #settingsCog:hover {
      color: #007bff;
    }

    h1 {
      /* Though no H1 is in the HTML, good to have a base style */
      color: #333;
      margin-bottom: 20px;
    }

    textarea {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
      /* Ensure padding and border are inside width/height */
      border-radius: 4px;
      resize: vertical;
      min-height: 100px;
    }

    input[type="text"],
    select {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
      border-radius: 4px;
    }

    button {
      background-color: #007bff;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:disabled {
      /* Style for disabled button */
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .message {
      margin-top: 10px;
      color: red;
      /* Default to red, can be changed by JS */
      font-weight: bold;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-left-color: #007bff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      /* MODIFICATION: Spinner will be the only content in loadingIndicator, so no margin needed here */
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loadingIndicator {
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 30px;
    }

    /* MODIFICATION: Style for the cipher text */
    #loadingText {
      font-family: 'Courier New', Courier, monospace;
      /* Optional: for a more cipher-like feel */
      display: inline-block;
      margin-left: 10px;
      /* Spacing between spinner and text */
    }

    /* New styles for progress bar */
    #overallProgressBarContainer {
      width: 80%;
      background-color: #e0e0e0;
      border-radius: 5px;
      height: 10px;
      margin-top: 10px;
      overflow: hidden;
      display: flex; /* Make it a flex container */
      position: relative; /* Ensure this is relative for absolute children */
    }

    .progress-segment {
      flex-grow: 1; /* Allow segments to grow based on content (width will be set dynamically) */
      height: 100%;
      background-color: #a0a0a0; /* Default pending color */
      border-right: 1px solid #c0c0c0; /* Separator between segments */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      position: relative; /* For inner fill positioning */
      overflow: hidden; /* Hide overflow of inner fill */
    }

    .progress-segment:last-child {
      border-right: none; /* No border on the last segment */
    }

    .segment-fill {
      height: 100%;
      width: 0%; /* Initial state */
      background-color: #007bff; /* Progress fill color */
      transition: width 0.1s ease-out;
    }

    .progress-segment.active {
      background-color: #6a9bd8; /* Slightly darker blue for active segment */
    }

    .progress-segment.completed .segment-fill {
      background-color: #28a745; /* Green for completed segments */
      width: 100%; /* Ensure completed segment fills entirely */
    }

    .progress-segment.failed .segment-fill {
      background-color: #dc3545; /* Red for failed segments */
      width: 100%; /* Ensure failed segment fills entirely */
    }

    #playbackProgressBarContainer {
      position: absolute; /* Added */
      left: 0;           /* Added */
      top: 0;            /* Added */
      width: 100%;       /* Changed from 80% */
      height: 100%;      /* Changed from 10px */
      background-color: transparent; /* Changed from #e0e0e0 */
      border-radius: 5px;
      /* margin-top: 10px; */ /* Removed */
      overflow: hidden;
      z-index: 2;        /* Added */
    }

    #playbackProgressBar {
      height: 100%;
      width: 0%;
      background-color: #28a745; /* Green color for playback */
      border-radius: 5px;
      transition: width 0.1s ease-out;
      position: absolute; /* Added */
      top: 0;             /* Added */
    }
    

    /* --- MODIFICATION: Toast Notification Styles --- */
    .toast-container {
      position: fixed;
      top: 20px;
      /* MODIFICATION: Adjust if it overlaps with the new input bar, maybe lower or different corner */
      /* Let's move it down a bit to ensure it doesn't overlap with a potentially tall input bar if window is small */
      right: 20px;
      z-index: 1050;
      /* Ensure it's above other elements */
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      padding: 12px 20px;
      border-radius: 6px;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      opacity: 0;
      transform: translateX(110%);
      /* Start off-screen to the right */
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
      min-width: 280px;
      max-width: 350px;
      word-wrap: break-word;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.toast-info {
      background-color: #17a2b8;
    }

    .toast.toast-success {
      background-color: #28a745;
    }

    .toast.toast-error {
      background-color: #dc3545;
    }

    .toast.toast-warning {
      background-color: #ffc107;
      color: #212549;
    }

    /* Darker text for yellow */
    /* --- END MODIFICATION: Toast Notification Styles --- */

    /* New styles for highlighting */
    .text-display-area {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 8px;
      background-color: #f9f9f9;
      text-align: left;
      line-height: 1.6;
      font-size: 1.1em;
      color: #333;
      display: inline-block;
      /* Changed from none to inline-block to ensure rendering */
      /* Hidden by default, shown when text is entered */
    }

    .highlighted-word {
      background-color: #a8d9ff;
      /* Light blue background for highlighting */
      border-radius: 3px;
      padding: 2px 4px;
      margin: 0 -4px;
      /* Adjust margin to prevent gap between words */
      transition: background-color 0.2s ease;
    }

    /* MODIFICATION: Styles for the new model and voice selection container */
    .model-voice-selection {
      display: flex;
      flex-wrap: wrap; /* Allow items to wrap on smaller screens */
      justify-content: center;
      gap: 20px; /* Space between the select groups */
      margin: 20px auto; /* Center the container below the top bar */
      width: 90%;
      max-width: 700px;
      padding: 15px 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      box-sizing: border-box;
    }

    .select-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Align label and select to the start */
      gap: 5px; /* Space between label and select */
      flex-basis: calc(50% - 10px); /* Roughly 50% width minus half the gap */
      min-width: 250px; /* Minimum width for responsiveness */
    }

    .select-group label {
      font-weight: bold;
      color: #555;
      margin-bottom: 5px; /* Add a small margin for visual separation */
    }

    .select-group select {
      width: 100%; /* Ensure select fills its container */
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 1em;
    }
  </style>
</head>
 
<body>
  <div id="settingsCog" title="Show/Hide API Key">&#9881;</div>
  <div class="top-input-bar">
    <div class="input-group">
      <textarea id="textInput" placeholder="Enter text here..." rows="3"></textarea>
      <select id="splittingInput" style="display: inline-block; /* Changed from none to inline-block to ensure rendering */">
        <option value="sentence">Sentence by Sentence</option>
        <option value="tokenCount">Sentence by Token Count</option>
        <option value="none">No Splitting</option>
      
      </select>
      <input type="text" id="apiKeyInput" placeholder="Enter your API Key">
      <button id="speakButton">Speak</button>
    </div>
  </div>

  <div class="model-voice-selection">
    <div class="select-group">
      <label for="ttsModelInput">Model:</label>
      <select id="ttsModelInput">
        <option value="gemini-2.5-flash-preview-tts">gemini-2.5-flash-preview-tts</option>
        <option value="other-model-1">Other Model 1</option>
        <option value="other-model-2">Other Model 2</option>
      </select>
    </div>
    <div class="select-group">
      <label for="voiceIdInput">Voice:</label>
      <select id="voiceIdInput">
        <option value="achernar">achernar</option>
        <option value="achird">achird</option>
        <option value="algenib">algenib</option>
        <option value="algieba">algieba</option>
        <option value="alnilam">alnilam</option>
        <option value="aoede">aoede</option>
        <option value="autonoe">autonoe</option>
        <option value="callirrhoe">callirrhoe</option>
        <option value="charon">charon</option>
        <option value="despina">despina</option>
        <option value="erinome">erinome</option>
        <option value="fenrir">fenrir</option>
        <option value="gacrux">gacrux</option>
        <option value="iapetus">iapetus</option>
        <option value="kore">kore</option>
        <option value="laomedeia">laomedeia</option>
        <option value="leda">leda</option>
        <option value="orus">orus</option>
        <option value="puck">puck</option>
        <option value="pulcherrima">pulcherrima</option>
        <option value="rasalgethi">rasalgethi</option>
        <option value="sadachbia">sadachbia</option>
        <option value="sadaltager">sadaltager</option>
        <option value="schedar">schedar</option>
        <option value="sulafat">sulafat</option>
        <option value="umbriel">umbriel</option>
        <option value="vindemiatrix">vindemiatrix</option>
        <option value="zephyr">zephyr</option>
        <option value="zubenelgenubi">zubenelgenubi</option>
      </select>
    </div>
  </div>
 
   <div class="container">
 
    <a id="downloadButton" download="audio.wav" style="display: inline-block; /* Changed from none to inline-block to ensure rendering */ margin-top: 15px;">
      <button>Download WAV</button>
    </a>
    <div id="loadingIndicator" style="display: inline-block; /* Changed from none to inline-block to ensure rendering */">
      <div class="spinner"></div>
      <span id="loadingText">Connecting...</span>
    </div>
    <label>Overall Progress:</label>
    <div id="overallProgressBarContainer" style="display: block;">
      <div id="playbackProgressBarContainer" style="display: block;">
        <div id="playbackProgressBar"></div>
      </div>
    </div>
    <div id="message" class="message"></div>
    <div id="toastContainer" class="toast-container"></div>
    <!-- New section for displaying text and highlighting -->
    <div id="textDisplayArea" class="text-display-area"></div>
  </div>
 
  <script>
    function setupTTSClient(orchestratorWorkerUrl) {
      window.ORCHESTRATOR_WORKER_URL = orchestratorWorkerUrl; // Ensure this is configured
      
 
      let audioContext;
      let audioQueue = [];
      let currentSource = null;
      let playStartTime = 0;
      let lastPlayedIndex = -1;
      let cumulativeAudioDuration = 0;
      let connectionErrorOccurred = false;
      let fullAudioBuffers = []; // Array to store all decoded audio buffers for reconstruction
      let currentHighlightedWordIndex = 0; // New: To keep track of the currently highlighted word
      let words = []; // New: To store the words from the input text
      let currentSentenceIndex = -1; // New: To track the currently playing sentence index
 
      function showToast(message, type = 'info', duration = 4000) {
        const toastContainer = document.getElementById('toastContainer');
        const messageDiv = document.getElementById('message'); // Fallback
 
        if (!toastContainer) {
          if (messageDiv) {
            messageDiv.textContent = `[${type.toUpperCase()}] ${message}`;
            messageDiv.style.color = type === 'error' ? 'red' : (type === 'success' ? 'green' : 'black');
          }
          console.warn("Toast container not found. Using fallback message div.");
          return;
        }
 
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
 
        setTimeout(() => toast.classList.add('show'), 10);
 
        setTimeout(() => {
          toast.classList.remove('show');
          toast.addEventListener('transitionend', () => toast.remove(), {
            once: true
          });
        }, duration);
      }
 
      // Refactored function to remove SSE logic and prepare for fetch-based requests
      const initiateTtsRequest = async (text, voiceName, apiKey, downloadButtonLink, speakButton, loadingIndicator, loadingText, overallProgressBarContainer, playbackProgressBarContainer, playbackProgressBar, textDisplayArea, splitting, model) => {
        // Clear existing state related to previous playback or SSE
        words = text.split(/\b(\w+)\b|\s+/).filter(Boolean).map((word, index) => {
          if (word.match(/\b(\w+)\b/)) {
            return {
              text: word,
              originalIndex: index,
              element: null,
              sentenceIndex: -1
            };
          }
          return {
            text: word,
            originalIndex: index,
            element: null,
            isSeparator: true,
            sentenceIndex: -1
          };
        });
        currentHighlightedWordIndex = 0;
        currentSentenceIndex = -1;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        cumulativeAudioDuration = 0;
        lastPlayedIndex = -1;
        audioQueue = [];
        fullAudioBuffers = [];
        currentSource = null;
 
        loadingText.textContent = 'Playing...';
        overallProgressBarContainer.style.display = 'block';
        
        playbackProgressBarContainer.style.display = 'none';
        playbackProgressBar.style.width = '0%';
 
        const MAX_RETRIES = 4; // 0-indexed, so 5 attempts
        const INITIAL_BACKOFF_MS = 500; // 2^n * 500ms
        const POLLING_INTERVAL_MS = 1500; // 1.5 seconds
        const MAX_POLLING_TIME_MS = 90000; // 90 seconds
 
        const delay = ms => new Promise(res => setTimeout(res, ms));
 
        // Helper function to process audio chunks
        const processAudioChunk = async (audioBase64, sentenceMapping, currentChunkIndex) => {
          const audioBinary = atob(audioBase64); // Decode base64 to binary string
          const audioBytes = new Uint8Array(audioBinary.length);
          for (let i = 0; i < audioBinary.length; i++) {
            audioBytes[i] = audioBinary.charCodeAt(i);
          }
 
          return new Promise((resolve, reject) => {
            audioContext.decodeAudioData(audioBytes.buffer, (buffer) => {
              fullAudioBuffers.push({ buffer, index: currentChunkIndex });
              audioQueue.push({ buffer, index: currentChunkIndex, sentenceMapping });
              if (!currentSource) {
                playNextChunk(textDisplayArea, playbackProgressBar, playbackProgressBarContainer);
              }
 
              // Update word sentence indices
              sentenceMapping.forEach(mapping => {
                  const mappedSentenceIndex = mapping.sentenceIndex;
                  mapping.wordIndexes.forEach(wordOriginalIndex => {
                      const wordObj = words.find(w => w.originalIndex === wordOriginalIndex);
                      if (wordObj) {
                          wordObj.sentenceIndex = mappedSentenceIndex;
                      }
                  });
              });
 
              // Mark the current segment as completed (or processed)
              const currentSegment = window.ttsJobData.segmentElements[currentChunkIndex];
              if (currentSegment) {
                currentSegment.classList.remove('active');
                currentSegment.classList.add('completed');
                currentSegment.querySelector('.segment-fill').style.width = '100%'; // Ensure it's fully filled
              }
 
              // Update cumulative completed length (for overall progress conceptualization)
              window.ttsJobData.cumulativeCompletedLength += window.ttsJobData.chunkLengths[currentChunkIndex];
 
              // No longer directly setting overallProgressBar width here, as it's segmented
              resolve();
            }, reject);
          });
        };
        const wordSpans = textDisplayArea.querySelectorAll('span[data-word-index]');
        wordSpans.forEach(span => {
          const originalIndex = parseInt(span.dataset.wordIndex);
          const wordObj = words.find(w => w.originalIndex === originalIndex);
          if (wordObj) {
            wordObj.element = span;
          }
        });
        clearAllHighlights(textDisplayArea);
 
        // This function will be adapted in a later step to manage `fetch`-based sequential requests.
        // For now, it only prepares the state and clears previous SSE-related logic.
        try {
          loadingText.textContent = 'Initiating TTS request...';
          const abortControllerInitiate = new AbortController();
          const initialFetchTimeout = orchestratorTimeoutMs ? Math.min(orchestratorTimeoutMs + 20000, 80000) : 20000; // Use orchestrator's recommendation + buffer, capped, or fallback to 20s
          console.log(`Setting initial TTS fetch timeout to: ${initialFetchTimeout}ms`); // Added logging
          const initiateTimeout = setTimeout(() => abortControllerInitiate.abort(), initialFetchTimeout);
          const response = await fetch(`${window.ORCHESTRATOR_WORKER_URL}/api/tts-initiate`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              fullText: text,
              voiceId: voiceName,
              model: model,
              splittingPreference: splitting
            }),
            signal: abortControllerInitiate.signal
          });
          clearTimeout(initiateTimeout);
 
          if (!response.ok) {
            let errorMessage = `HTTP error! status: ${response.status}`;
            try {
              const errorData = await response.json();
              errorMessage = errorData.error || errorMessage;
            } catch (jsonError) {
              try {
                const errorText = await response.text();
                errorMessage = errorText || errorMessage;
              } catch (textError) {
                // Could not parse as JSON or text
                // Fallback to default message
              }
            }
            throw new Error(errorMessage);
          }
 
          const { jobId, totalChunks, chunkLengths, orchestratorTimeoutMs } = await response.json();
          showToast(`TTS initiated. Job ID: ${jobId}, Total Chunks: ${totalChunks}`, 'success');
 
          // Store chunk lengths globally
          window.ttsJobData = {
            chunkLengths: chunkLengths,
            totalTextLength: chunkLengths.reduce((sum, length) => sum + length, 0),
            cumulativeCompletedLength: 0,
            segmentElements: [], // To store references to created segment divs
            orchestratorTimeoutMs: orchestratorTimeoutMs // Store the initial orchestrator timeout
          };
 
          // Initial rendering of segmented progress bar
          overallProgressBarContainer.style.display = 'flex'; // Ensure it's a flex container
          overallProgressBarContainer.innerHTML = ''; // Clear existing content (e.g., old overallProgressBar)
          chunkLengths.forEach((length, index) => {
            const segment = document.createElement('div');
            segment.className = 'progress-segment';
            segment.dataset.chunkIndex = index;
            segment.style.width = `${(length / window.ttsJobData.totalTextLength) * 100}%`;
 
            const segmentFill = document.createElement('div');
            segmentFill.className = 'segment-fill';
            segment.appendChild(segmentFill);
            overallProgressBarContainer.appendChild(segment);
            window.ttsJobData.segmentElements.push(segment); // Store reference
          });
 
          loadingText.textContent = 'Fetching audio chunks...';
          playbackProgressBarContainer.style.display = 'none';
          playbackProgressBar.style.width = '0%';
 
          // Function to fetch individual audio chunks - Refactored to use iteration
          let chunkIndex = 0;
          while (chunkIndex < totalChunks) {
            let retries = 0;
            let chunkData = null; // Reset chunkData for each chunk
            let chunkHandled = false; // Flag to indicate if the chunk was successfully fetched or intentionally skipped
 
            while (retries <= MAX_RETRIES && !chunkHandled) { // Loop while retries available and chunk not handled
              try {
                loadingText.textContent = `Fetching chunk ${chunkIndex + 1}/${totalChunks} (attempt ${retries + 1}/${MAX_RETRIES + 1})...`;
 
                const abortControllerChunk = new AbortController();
                // Assuming orchestratorTimeoutMs is available in a previous response or has a default
                // For the initial chunk, we don't have it yet, so we'll use a default or assume it's part of the initiate response.
                // Since the task implies it's per-chunk, I'll assume for the first chunk it's 0 and the +5000 applies.
                // Later chunks might receive this info from the orchestrator. For now, we'll implement the logic assuming its presence.
                const orchestratorDynamicTimeout = window.ttsJobData.orchestratorTimeoutMs || 0;
                const dynamicChunkTimeout = Math.min(orchestratorDynamicTimeout + 20000, 80000); // Capped at 80 seconds
                const chunkTimeout = setTimeout(() => abortControllerChunk.abort(), dynamicChunkTimeout);
 
                const chunkResponse = await fetch(`${window.ORCHESTRATOR_WORKER_URL}/api/tts-chunk?jobId=${jobId}&chunkIndex=${chunkIndex}`, {
                  method: 'GET',
                  headers: {
                    'Authorization': `Bearer ${apiKey}`
                  },
                  signal: abortControllerChunk.signal
                });
                clearTimeout(chunkTimeout);
 
                if (chunkResponse.status === 202) { // 202 Accepted: Chunk is in progress
                  showToast(`Chunk ${chunkIndex + 1} is in progress. Polling...`, 'info');
                  let pollingStartTime = Date.now();
                  let polledResponse = null;
 
                  while (Date.now() - pollingStartTime < MAX_POLLING_TIME_MS) {
                    await delay(POLLING_INTERVAL_MS);
                    const pollingAttemptResponse = await fetch(`${window.ORCHESTRATOR_WORKER_URL}/api/tts-chunk?jobId=${jobId}&chunkIndex=${chunkIndex}`, {
                      method: 'GET',
                      headers: {
                        'Authorization': `Bearer ${apiKey}`
                      }
                    });
 
                    if (pollingAttemptResponse.ok && pollingAttemptResponse.status !== 202) {
                      polledResponse = pollingAttemptResponse;
                      break; // Exit polling loop, chunk is ready
                    } else if (pollingAttemptResponse.status === 410) {
                      console.warn(`Chunk ${chunkIndex + 1} permanently failed during polling.`);
                      showToast(`Warning: Segment ${chunkIndex + 1} failed and will be skipped.`, 'warning');
                      const segment = window.ttsJobData.segmentElements[chunkIndex];
                      if (segment) {
                        segment.classList.add('failed');
                      }
                      chunkHandled = true; // Mark as handled, no chunkData
                      break; // Exit polling loop
                    } else if (!pollingAttemptResponse.ok && pollingAttemptResponse.status !== 202) {
                      const errorData = await pollingAttemptResponse.json();
                      console.error(`Error polling for chunk ${chunkIndex + 1}:`, errorData);
                      showToast(`Error: Failed to retrieve segment ${chunkIndex + 1} due to server error during polling. Skipping.`, 'error');
                      const segment = window.ttsJobData.segmentElements[chunkIndex];
                      if (segment) {
                        segment.classList.add('failed');
                      }
                      chunkHandled = true; // Mark as handled, no chunkData
                      break; // Exit polling loop
                    }
                  }
 
                  if (polledResponse) {
                    chunkData = await polledResponse.json();
                    chunkHandled = true; // Successfully fetched after polling
                  } else if (!chunkHandled) { // Polling timed out and not already handled by 410/other error
                    console.error(`Polling for chunk ${chunkIndex + 1} timed out after ${MAX_POLLING_TIME_MS / 1000} seconds.`);
                    showToast(`Error: Polling for segment ${chunkIndex + 1} timed out. Skipping.`, 'error');
                    const segment = window.ttsJobData.segmentElements[chunkIndex];
                    if (segment) {
                      segment.classList.add('failed');
                    }
                    chunkHandled = true; // Mark as handled, no chunkData
                  }
 
                } else if (chunkResponse.status === 410) { // 410 Gone: Permanent failure
                  console.warn(`Chunk ${chunkIndex + 1} permanently failed.`);
                  showToast(`Warning: Segment ${chunkIndex + 1} failed and will be skipped.`, 'warning');
                  const segment = window.ttsJobData.segmentElements[chunkIndex];
                  if (segment) {
                    segment.classList.add('failed');
                  }
                  chunkHandled = true; // Mark as handled, no chunkData
                } else if (!chunkResponse.ok) { // Other non-200, non-202, non-410 error
                  let chunkErrorMessage = `Error fetching chunk ${chunkIndex + 1}: HTTP status ${chunkResponse.status}`;
                  try {
                    const errorData = await chunkResponse.json();
                    chunkErrorMessage = errorData.error || chunkErrorMessage;
                  } catch (jsonError) {
                    try {
                      const errorText = await chunkResponse.text();
                      chunkErrorMessage = errorText || chunkErrorMessage;
                    } catch (textError) {
                      // Could not parse as JSON or text
                      // Fallback to default message
                    }
                  }
                  console.error(chunkErrorMessage);
                  showToast(`Error: ${chunkErrorMessage}. Skipping.`, 'error');
                  const segment = window.ttsJobData.segmentElements[chunkIndex];
                  if (segment) {
                    segment.classList.add('failed');
                  }
                  chunkHandled = true; // Mark as handled, no chunkData
                } else { // 200 OK: Success
                  chunkData = await chunkResponse.json();
                  chunkHandled = true; // Successfully fetched
                }
 
              } catch (error) { // Catch network errors or errors thrown from polling logic
                if (error.name === 'AbortError') {
                  console.error(`Chunk ${chunkIndex + 1} request timed out (attempt ${retries + 1}).`);
                  showToast(`Error: Segment ${chunkIndex + 1} request timed out. Retrying...`, 'warning');
                } else {
                  console.error(`Error fetching chunk ${chunkIndex + 1} (attempt ${retries + 1}):`, error);
                  showToast(`Error fetching chunk ${chunkIndex + 1}: ${error.message}. Retrying...`, 'warning');
                }
                retries++;
                if (retries > MAX_RETRIES) {
                  // All retries failed for a transient error, skip this chunk
                  console.error(`Failed to fetch chunk ${chunkIndex + 1} after ${MAX_RETRIES + 1} attempts. Skipping chunk.`);
                  showToast(`Error: Failed to retrieve segment ${chunkIndex + 1} after multiple attempts. Skipping.`, 'error');
                  const segment = window.ttsJobData.segmentElements[chunkIndex];
                  if (segment) {
                    segment.classList.add('failed');
                  }
                  chunkHandled = true; // Mark as handled, no chunkData
                } else {
                  const backoffTime = INITIAL_BACKOFF_MS * Math.pow(2, retries - 1);
                  await delay(backoffTime);
                }
              }
            }
 
            if (chunkData) {
              await processAudioChunk(chunkData.audioContentBase64, chunkData.sentenceMapping, chunkIndex);
            } else {
                // If chunkData is null (due to skip/failure), still mark the segment as failed if not already
                const segment = window.ttsJobData.segmentElements[chunkIndex];
                if (segment && !segment.classList.contains('failed')) {
                    segment.classList.add('failed');
                }
            }
            chunkIndex++; // Always increment chunkIndex to move to the next chunk, regardless of success or failure
          }
 
          // Completion logic after the loop finishes
          showToast('All audio chunks processed (some may have been skipped/failed).', 'success');
          loadingText.textContent = 'Playback complete.';
          // No longer setting overallProgressBar width here, as it's segmented
          speakButton.disabled = false;
          loadingIndicator.style.display = 'none';
          // overallProgressBarContainer.style.display = 'none'; // Keep visible if segments are shown
 
          // Concatenate all buffers and enable download
          if (fullAudioBuffers.length > 0) {
fullAudioBuffers.sort((a, b) => a.index - b.index);
            const audioBlob = bufferToWave(concatenateAudioBuffers(fullAudioBuffers, audioContext), fullAudioBuffers.reduce((acc, val) => acc + val.buffer.length, 0));
            downloadButtonLink.href = URL.createObjectURL(audioBlob);
            downloadButtonLink.style.display = 'block';
          }
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.error('Initial TTS Request Timed Out:', error);
            showToast('Error: Initial TTS request timed out after 15 seconds. Please try again.', 'error');
          } else {
            console.error('Initial TTS Request Error:', error);
            showToast(`Error initiating TTS: ${error.message}`, 'error');
          }
          speakButton.disabled = false;
          loadingIndicator.style.display = 'none';
        }
      };
 
      const playNextChunk = (textDisplayArea, playbackProgressBar, playbackProgressBarContainer) => {
        if (audioQueue.length > 0) {
          const { buffer, index } = audioQueue.shift();
 
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
 
          let scheduledTime = cumulativeAudioDuration;
          if (scheduledTime < audioContext.currentTime) {
            scheduledTime = audioContext.currentTime;
          }
 
          // Get the current progress segment and mark it active
          const currentSegment = window.ttsJobData.segmentElements[index];
          if (currentSegment) {
            // First, remove active class from any previously active segment
            document.querySelectorAll('.progress-segment.active').forEach(s => s.classList.remove('active'));
            currentSegment.classList.add('active');
          }
 
          // Position playbackProgressBar over the active segment
          playbackProgressBarContainer.style.display = 'block'; // Keep this to show/hide the container
          // Removed: playbackProgressBarContainer.style.position = 'absolute';
          playbackProgressBar.style.left = `${currentSegment.offsetLeft}px`;
          playbackProgressBar.style.width = `${currentSegment.offsetWidth}px`;
          // Removed: playbackProgressBarContainer.style.top = `${currentSegment.offsetTop}px`;
          // Removed: playbackProgressBarContainer.style.height = `${currentSegment.offsetHeight}px`;
          playbackProgressBar.style.width = '0%'; // Reset for new chunk
 
          playStartTime = audioContext.currentTime;
          source.start(scheduledTime);
          currentSource = source;
          lastPlayedIndex = index;
          cumulativeAudioDuration += buffer.duration;
 
          const updatePlaybackProgress = () => {
            if (currentSource && audioContext) {
              const elapsed = audioContext.currentTime - playStartTime;
              const duration = buffer.duration;
              const progress = (elapsed / duration) * 100;
              playbackProgressBar.style.width = `${progress}%`;
 
              if (elapsed < duration) {
                requestAnimationFrame(updatePlaybackProgress);
              } else {
                // Playback for this chunk is complete
                playbackProgressBar.style.width = '0%'; // Reset its progress bar
              }
            }
          };
          requestAnimationFrame(updatePlaybackProgress);
 
          // Highlight current sentence
          clearAllHighlights(textDisplayArea);
          currentSentenceIndex = index;
          words.forEach(word => {
            if (word.element && word.sentenceIndex === currentSentenceIndex) {
              word.element.classList.add('highlighted-word');
            }
          });
 
          source.onended = () => {
            // Mark the current segment as completed
            if (currentSegment) {
              currentSegment.classList.remove('active');
              currentSegment.classList.add('completed');
              currentSegment.querySelector('.segment-fill').style.width = '100%';
            }
 
            if (audioQueue.length > 0) {
              playNextChunk(textDisplayArea, playbackProgressBar, playbackProgressBarContainer);
            } else {
              currentSource = null;
              clearAllHighlights(textDisplayArea);
              // All chunks are done, clear segments and hide playback bar
              playbackProgressBarContainer.style.display = 'none';
              playbackProgressBar.style.width = '0%';
              overallProgressBarContainer.style.display = 'none'; // Hide overall progress bar on full completion
            }
          };
        }
      };
 
      function clearAllHighlights(textDisplayArea) {
        textDisplayArea.querySelectorAll('.highlighted-word').forEach(element => {
          element.classList.remove('highlighted-word');
        });
      }
 
// New function to concatenate multiple AudioBuffer objects
      function concatenateAudioBuffers(audioBuffers, audioContext) {
        if (!audioBuffers || audioBuffers.length === 0) {
          return null;
        }
 
        const numberOfChannels = audioBuffers[0].numberOfChannels;
        const sampleRate = audioBuffers[0].sampleRate;
        let totalLength = 0;
        for (const buffer of audioBuffers) {
          totalLength += buffer.length;
        }
 
        const outputBuffer = audioContext.createBuffer(numberOfChannels, totalLength, sampleRate);
 
        let offset = 0;
        for (const buffer of audioBuffers) {
          for (let i = 0; i < numberOfChannels; i++) {
            outputBuffer.getChannelData(i).set(buffer.getChannelData(i), offset);
          }
          offset += buffer.length;
        }
        return outputBuffer;
      }
      function bufferToWave(abuffer, len) {
        var numOfChan = abuffer.numberOfChannels;
        var bitsPerSample = 16; // Standard for PCM, as currently implemented
        var bytesPerSample = bitsPerSample / 8; // 2 bytes for 16-bit
        var length = len * numOfChan * bytesPerSample + 44; // Calculate total length dynamically
        var buffer = new ArrayBuffer(length);
        var view = new DataView(buffer);
        var channels = [];
        var i, sample;
        var offset = 0;
        var pos = 0;
 
        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"
 
        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16); // length = 16
        setUint16(1); // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * numOfChan * bytesPerSample); // avg. bytes/sec
        setUint16(numOfChan * bytesPerSample); // block-align
        setUint16(bitsPerSample); // bits-per-sample
 
        setUint32(0x61746164); // "data" chunk
        setUint32(length - 44); // chunk length
 
        for (i = 0; i < abuffer.numberOfChannels; i++)
          channels.push(abuffer.getChannelData(i));
 
        while (pos < length) {
          for (i = 0; i < numOfChan; i++) {
            sample = Math.max(-1, Math.min(1, channels[i][offset]));
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
            view.setInt16(pos, sample, true);
            pos += 2;
          }
          offset++
        }
 
        return new Blob([buffer], {
          type: 'audio/wav'
        });
 
        function setUint16(data) {
          view.setUint16(pos, data, true);
          pos += 2;
        }
 
        function setUint32(data) {
          view.setUint32(pos, data, true);
          pos += 4;
        }
      }
 
      return {
        initiateTtsRequest, // Renamed from connectToEventSource
        showToast,
        bufferToWave
      };
    }
 
 
    document.addEventListener('DOMContentLoaded', () => {
      const apiKeyInput = document.getElementById('apiKeyInput');
      const splittingInput = document.getElementById('splittingInput'); // Get the new splitting input
      const settingsCog = document.getElementById('settingsCog');
      const storedApiKey = localStorage.getItem('apiKey');
      const textInput = document.getElementById('textInput');
      const textDisplayArea = document.getElementById('textDisplayArea');
      const loadingText = document.getElementById('loadingText');
      const overallProgressBarContainer = document.getElementById('overallProgressBarContainer');
      
      const playbackProgressBarContainer = document.getElementById('playbackProgressBarContainer');
      const playbackProgressBar = document.getElementById('playbackProgressBar');
      
 
 
      // This should be configured at deployment, e.g., by a build process or environment variable
      // For local testing, you might hardcode it or use a simple config mechanism.
      // const ORCHESTRATOR_WORKER_URL = '{{ORCHESTRATOR_WORKER_URL}}'; // Replaced with placeholder
  
      const {
        initiateTtsRequest, // Renamed from connectToEventSource
        showToast
      } = setupTTSClient(window.ttsConfig.ORCHESTRATOR_WORKER_URL);
 
 
      if (storedApiKey) {
        apiKeyInput.value = storedApiKey;
        apiKeyInput.type = 'password';
        apiKeyInput.style.display = 'none';
        splittingInput.style.display = 'none'; // Also hide splitting input if API key is stored
        settingsCog.style.display = 'inline-block';
      } else {
        apiKeyInput.style.display = 'block';
        splittingInput.style.display = 'block'; // Show splitting input if API key is not stored
        settingsCog.style.display = 'inline- quizÃ¡sblock';
      }
      const ttsModelInput = document.getElementById('ttsModelInput');
      const storedTtsModel = localStorage.getItem('ttsModel');
      if (storedTtsModel) {
        ttsModelInput.value = storedTtsModel;
      }
      // ttsModelInput.style.display = 'inline-block'; // Removed, as it's now handled by the new container's display
      ttsModelInput.addEventListener('change', (event) => {
        localStorage.setItem('ttsModel', event.target.value);
      });

      const storedVoiceId = localStorage.getItem('voiceId');
      if (storedVoiceId) {
        document.getElementById('voiceIdInput').value = storedVoiceId;
      }

      const topInputBar = document.querySelector('.top-input-bar');
      const modelVoiceSelection = document.querySelector('.model-voice-selection');

      function updateBodyPadding() {
        if (topInputBar && modelVoiceSelection) {
          const totalFixedElementsHeight = topInputBar.offsetHeight + modelVoiceSelection.offsetHeight;
          document.body.style.paddingTop = `${totalFixedElementsHeight + 20}px`;
        }
      }

      if (topInputBar && modelVoiceSelection) {
        updateBodyPadding();
        window.addEventListener('resize', updateBodyPadding);
        // Observe changes to the height of both fixed elements
        new ResizeObserver(updateBodyPadding).observe(topInputBar);
        new ResizeObserver(updateBodyPadding).observe(modelVoiceSelection);
      }

      settingsCog.addEventListener('click', () => {
        const isApiKeyHidden = apiKeyInput.style.display === 'none';
        const isSplittingHidden = splittingInput.style.display === 'none';

        // Toggle API Key and Splitting Input visibility
        apiKeyInput.style.display = isApiKeyHidden ? 'block' : 'none';
        splittingInput.style.display = isSplittingHidden ? 'block' : 'none';

        // Set API Key input type based on visibility
        if (isApiKeyHidden && apiKeyInput.value) {
          apiKeyInput.type = 'text';
        } else if (!isApiKeyHidden) {
          apiKeyInput.type = 'password';
        }
      });
 
      document.getElementById('voiceIdInput').addEventListener('change', (event) => {
        localStorage.setItem('voiceId', event.target.value);
      });
 
      document.getElementById('speakButton').addEventListener('click', async () => {
        const text = textInput.value;
        const voiceName = document.getElementById('voiceIdInput').value;
        const apiKey = document.getElementById('apiKeyInput').value;
        const splitting = splittingInput.value; // Get the selected splitting option
        const messageDiv = document.getElementById('message');
        const downloadButtonLink = document.getElementById('downloadButton');
        const speakButton = document.getElementById('speakButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
 
        messageDiv.textContent = '';
        downloadButtonLink.style.display = 'none';
        downloadButtonLink.href = '';
        speakButton.disabled = true;
        loadingIndicator.style.display = 'flex';
        loadingText.textContent = 'Connecting...';
        overallProgressBarContainer.innerHTML = ''; // Clear segments
        overallProgressBarContainer.style.display = 'none';
        
        playbackProgressBarContainer.style.display = 'none';
        playbackProgressBar.style.width = '0%';
        textDisplayArea.style.display = 'none'; // Hide text display initially
 
 
        if (!text || !apiKey) {
          showToast('Please enter text and API Key.', 'error');
          speakButton.disabled = false;
          loadingIndicator.style.display = 'none';
          return;
        }
 
        localStorage.setItem('apiKey', apiKey);
 
        // Prepare text for highlighting
        textDisplayArea.innerHTML = text.split(/\b(\w+)\b|\s+/).filter(Boolean).map((word, index) => {
          return word.match(/\b(\w+)\b/) ? `<span data-word-index="${index}">${word}</span>` : word;
        }).join('');
        textDisplayArea.style.display = 'block'; // Show text display
 
        try {
          // MODIFICATION: Define the default TTS model as a configurable global variable
      
 
      // Use the configurable model
      const model = document.getElementById('ttsModelInput').value;
          await initiateTtsRequest(text, voiceName, apiKey, downloadButtonLink, speakButton, loadingIndicator, loadingText, overallProgressBarContainer, playbackProgressBarContainer, playbackProgressBar, textDisplayArea, splitting, model); // Renamed from connectToEventSource
        } catch (error) {
          console.error('TTS Request Error:', error);
          showToast(`Error: ${error.message}`, 'error');
        } finally {
          speakButton.disabled = false;
          loadingIndicator.style.display = 'none';
        }
      });
    });
  </script>
</body>
 
</html>