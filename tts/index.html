<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTS Frontend</title>
  <style>
    /* MODIFICATION: Global reset and body styling for fixed header */
    body {
      font-family: Arial, sans-serif;
      /* display: flex; /* Removed for normal flow with fixed header */
      /* justify-content: center; */
      /* align-items: center; */
      /* min-height: 100vh; */
      background-color: #f4f4f4;
      margin: 0;
      padding-top: 230px;
      /* MODIFICATION: Add padding to body to offset fixed input bar height */
      /* This will be dynamically updated by JavaScript */
    }

    /* MODIFICATION: Style for the fixed input bar */
    .top-input-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #ffffff;
      padding: 15px 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      box-sizing: border-box;
    }

    .top-input-bar .input-group {
      /* MODIFICATION: For better layout within the bar */
      margin: 0 auto;
      /* Center the group */
      text-align: center;
    }

    .container {
      /* MODIFICATION: Container is no longer the main centering/positioning element for inputs */
      /* position: relative; /* Kept for cog icon positioning */
      display: flex;
      flex-direction: column; /* Added for better stacking of internal elements */
      align-items: center; /* Center items like download button, message */
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      width: 90%;
      max-width: 700px; /* Added for better responsiveness on large screens */
      text-align: center;
      margin: 20px auto;
      /* Centering the content box below the input bar */
      position: relative;
      /* For cog positioning inside this specific box if preferred */
    }

    /* MODIFICATION: Relative positioning for cog icon placement */
    /* Let's position cog relative to the main container, below the input bar */
    #settingsCog {
      position: fixed;
      /* Change to fixed positioning relative to viewport */
      top: 15px;
      right: 15px;
      cursor: pointer;
      font-size: 20px;
      /* Adjust size as needed */
      color: #555;
      display: none;
      /* Hidden by default, shown by JS if API key is set */
    }

    #settingsCog:hover {
      color: #007bff;
    }

    h1 { /* Though no H1 is in the HTML, good to have a base style */
      color: #333;
      margin-bottom: 20px;
    }

    textarea {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
      /* Ensure padding and border are inside width/height */
      border-radius: 4px;
      resize: vertical;
      min-height: 100px;
    }

    input[type="text"],
    select {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
      border-radius: 4px;
    }

    button {
      background-color: #007bff;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:disabled { /* Style for disabled button */
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .message {
      margin-top: 10px;
      color: red;
      /* Default to red, can be changed by JS */
      font-weight: bold;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-left-color: #007bff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      /* MODIFICATION: Spinner will be the only content in loadingIndicator, so no margin needed here */
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loadingIndicator {
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 30px;
    }

    /* MODIFICATION: Style for the cipher text */
    #loadingText {
      font-family: 'Courier New', Courier, monospace;
      /* Optional: for a more cipher-like feel */
      display: inline-block;
    }

    /* --- MODIFICATION: Toast Notification Styles --- */
    .toast-container {
      position: fixed;
      top: 20px;
      /* MODIFICATION: Adjust if it overlaps with the new input bar, maybe lower or different corner */
      /* Let's move it down a bit to ensure it doesn't overlap with a potentially tall input bar if window is small */
      right: 20px;
      z-index: 1050;
      /* Ensure it's above other elements */
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      padding: 12px 20px;
      border-radius: 6px;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      opacity: 0;
      transform: translateX(110%);
      /* Start off-screen to the right */
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
      min-width: 280px;
      max-width: 350px;
      word-wrap: break-word;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.toast-info {
      background-color: #17a2b8;
    }

    .toast.toast-success {
      background-color: #28a745;
    }

    .toast.toast-error {
      background-color: #dc3545;
    }

    .toast.toast-warning {
      background-color: #ffc107;
      color: #212549;
    }

    /* Darker text for yellow */
    /* --- END MODIFICATION: Toast Notification Styles --- */

    .sentence-container {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #eee;
      border-radius: 4px;
      text-align: left;
      line-height: 1.8;
      max-height: 150px; /* Consider making this more flexible or larger if needed */
      overflow-y: auto;
      width: 100%; /* Ensure it takes full width of its parent (.container) */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    .sentence-container span.sentence-segment {
      transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, transform 0.2s ease-in-out, box-shadow 0.2s ease-out, opacity 0.5s ease-out;
      padding: 2px 4px;
      margin-right: 4px;
      border-radius: 3px;
      display: inline;
      /* Changed from inline-block to inline for better flow with text justification */
      opacity: 0;
      border-right: 2px solid transparent;
    }

    .sentence-segment.initial-split-visual {
      border-right-color: #007bff;
      margin-right: 6px;
      padding-right: 6px;
    }

    .sentence-container span.sentence-segment.playing {
      background-color: #007bff;
      color: white;
      transform: scale(1.03);
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
    }

    /* MODIFICATION: CSS for redacted effect on sentences being fetched */
    .sentence-segment.fetching-redacted {
      color: transparent !important;
      /* Hide the actual text */
      background-color: #444 !important;
      /* Dark grey block for redaction */
      /* Opacity will still be controlled by fadeIn animation if not yet fully visible */
      /* transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; */
      /* The main transition on .sentence-segment already covers this */
    }


    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <div class="top-input-bar">
    <div class="input-group">
      <textarea id="textInput" placeholder="Enter text here..." rows="3"></textarea>
      <select id="voiceIdInput">
        <option value="achernar">achernar</option>
        <option value="achird">achird</option>
        <option value="algenib">algenib</option>
        <option value="algieba">algieba</option>
        <option value="alnilam">alnilam</option>
        <option value="aoede">aoede</option>
        <option value="autonoe">autonoe</option>
        <option value="callirrhoe">callirrhoe</option>
        <option value="charon">charon</option>
        <option value="despina">despina</option>
        <option value="enceladus">enceladus</option>
        <option value="erinome">erinome</option>
        <option value="fenrir">fenrir</option>
        <option value="gacrux">gacrux</option>
        <option value="iapetus">iapetus</option>
        <option value="kore">kore</option>
        <option value="laomedeia">laomedeia</option>
        <option value="leda">leda</option>
        <option value="orus">orus</option>
        <option value="puck">puck</option>
        <option value="pulcherrima">pulcherrima</option>
        <option value="rasalgethi">rasalgethi</option>
        <option value="sadachbia">sadachbia</option>
        <option value="sadaltager">sadaltager</option>
        <option value="schedar">schedar</option>
        <option value="sulafat">sulafat</option>
        <option value="umbriel">umbriel</option>
        <option value="vindemiatrix">vindemiatrix</option>
        <option value="zephyr">zephyr</option>
        <option value="zubenelgenubi">zubenelgenubi</option>
      </select>
      <input type="text" id="apiKeyInput" placeholder="Enter your API Key">
      <button id="speakButton">Speak</button>
    </div>
  </div>

  <div class="container">
    <div id="settingsCog" title="Show/Hide API Key">&#9881;</div>
    <div id="sentenceDisplayContainer" class="sentence-container"></div>
    <a id="downloadButton" download="audio.opus" style="display: none; margin-top: 15px;">
      <button>Download Opus</button>
    </a>
    <div id="loadingIndicator" style="display: none;">
      <div class="spinner"></div>
    </div>
    <div id="message" class="message"></div>
    <div id="toastContainer" class="toast-container"></div>
  </div>

  <script>
    window.ORCHESTRATOR_WORKER_URL = ''; // Ensure this is configured
    const SENTENCE_FETCH_TIMEOUT_MS = 15000;
    const FIRST_SENTENCE_TIMEOUT_MS = 20000;
    // MODIFICATION: Control concurrent fetches. Set to 1 for strictly sequential.
    let currentMaxConcurrentFetches = 2; // Start with a reasonable default
    const MAX_ALLOWED_CONCURRENCY = 5;
    const MIN_ALLOWED_CONCURRENCY = 1;
    let consecutiveSuccessfulFetches = 0;
    let failureCount = 0;
    const CONSECUTIVE_SUCCESS_TO_INCREASE = 3; // Number of consecutive successes to increase concurrency
    const FAILURE_TO_DECREASE = 1; // Number of failures to decrease concurrency


    document.addEventListener('DOMContentLoaded', () => {
      const apiKeyInput = document.getElementById('apiKeyInput');
      const settingsCog = document.getElementById('settingsCog');
      const storedApiKey = localStorage.getItem('apiKey');

      if (storedApiKey) {
        apiKeyInput.value = storedApiKey;
        apiKeyInput.type = 'password';
        apiKeyInput.style.display = 'none';
        settingsCog.style.display = 'inline-block';
      } else {
        apiKeyInput.style.display = 'block';
        settingsCog.style.display = 'inline-block';
      }

      const storedVoiceId = localStorage.getItem('voiceId');
      if (storedVoiceId) {
        document.getElementById('voiceIdInput').value = storedVoiceId;
      }

      const topInputBar = document.querySelector('.top-input-bar');
      function updateBodyPadding() {
        if (topInputBar) {
          const barHeight = topInputBar.offsetHeight;
          document.body.style.paddingTop = `${barHeight + 20}px`;
        }
      }

      if (topInputBar) {
        updateBodyPadding();
        window.addEventListener('resize', updateBodyPadding);
        new ResizeObserver(updateBodyPadding).observe(topInputBar);
      }

      settingsCog.addEventListener('click', () => {
        const isHidden = apiKeyInput.style.display === 'none';
        apiKeyInput.style.display = isHidden ? 'block' : 'none';
        if (isHidden && apiKeyInput.value) {
          apiKeyInput.type = 'text';
        } else if (!isHidden) {
          apiKeyInput.type = 'password';
        }
      });

      document.getElementById('voiceIdInput').addEventListener('change', (event) => {
        localStorage.setItem('voiceId', event.target.value);
      });
    });

    function showToast(message, type = 'info', duration = 4000) {
      const toastContainer = document.getElementById('toastContainer');
      const messageDiv = document.getElementById('message'); // Fallback

      if (!toastContainer) {
        if (messageDiv) {
          messageDiv.textContent = `[${type.toUpperCase()}] ${message}`;
          messageDiv.style.color = type === 'error' ? 'red' : (type === 'success' ? 'green' : 'black');
        }
        console.warn("Toast container not found. Using fallback message div.");
        return;
      }

      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      toastContainer.appendChild(toast);

      setTimeout(() => toast.classList.add('show'), 10);

      setTimeout(() => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
      }, duration);
    }

    function applyRedactedStyle(spanElement) {
      if (!spanElement.hasAttribute('data-original-text')) {
        spanElement.setAttribute('data-original-text', spanElement.textContent);
      }
      spanElement.classList.add('fetching-redacted');
    }

    function removeRedactedStyle(spanElement) {
      spanElement.classList.remove('fetching-redacted');
      // const originalText = spanElement.getAttribute('data-original-text');
      // if (originalText && spanElement.textContent !== originalText) {
        // CSS handles text visibility, no need to restore textContent manually here
      // }
    }

    function splitIntoSentences(text) {
      const abbreviationPlaceholder = "###ABBR###";
      const decimalPlaceholder = "###DEC###";

      let processedText = text
        .replace(/(Mr|Mrs|Ms|Dr|Prof|Capt|Lt|Col|Gen|Rev|Fr|Sr|Jr|Maj|Gov|Sen|Rep|etc|e\.g|i\.e)\./g, `$1${abbreviationPlaceholder}`)
        .replace(/(\d+)\.(\d+)/g, `$1${decimalPlaceholder}$2`);

      const sentences = processedText.split(
        new RegExp(`(?<=[.!?])\\s*(?<!${abbreviationPlaceholder.replace('.', '\\.')})(?<!${decimalPlaceholder.replace('.', '\\.')})(?=\\S|$)`, 'g')
      );

      return sentences
        .map(s => s
          .replace(new RegExp(abbreviationPlaceholder, 'g'), '.')
          .replace(new RegExp(decimalPlaceholder, 'g'), '.')
          .trim()
        )
        .filter(s => s.length > 0 && /\S/.test(s));
    }


    document.getElementById('speakButton').addEventListener('click', async () => {
      const text = document.getElementById('textInput').value;
      const voiceId = document.getElementById('voiceIdInput').value;
      const apiKey = document.getElementById('apiKeyInput').value;
      const messageDiv = document.getElementById('message');
      const downloadButtonLink = document.getElementById('downloadButton');
      const speakButton = document.getElementById('speakButton');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const sentenceDisplayContainer = document.getElementById('sentenceDisplayContainer');

      sentenceDisplayContainer.innerHTML = '';
      let sentenceSpanElements = [];
      messageDiv.textContent = '';
      downloadButtonLink.style.display = 'none';
      downloadButtonLink.href = '';
      speakButton.disabled = true;
      loadingIndicator.style.display = 'flex';

      // MODIFICATION: Initialize resultsInOrder here
      let resultsInOrder = [];

      if (!text || !apiKey) {
        showToast('Please enter text and API Key.', 'error');
        speakButton.disabled = false;
        loadingIndicator.style.display = 'none';
        return;
      }
      if (!window.ORCHESTRATOR_WORKER_URL) {
        showToast('Error: Orchestrator URL not configured.', 'error');
        speakButton.disabled = false;
        loadingIndicator.style.display = 'none';
        return;
      }

      localStorage.setItem('apiKey', apiKey);
      let audioContext;
      let audioDestinationNode;
      let mediaRecorder;
      let recordedChunks = [];

      try {
        const sentences = splitIntoSentences(text);

        if (sentences.length > 0) {
          sentences.forEach((sentenceText, index) => {
            const span = document.createElement('span');
            span.textContent = sentenceText;
            span.setAttribute('data-original-text', sentenceText); // Store original text for redaction if needed
            span.id = `sentence-tts-${index}`;
            span.className = 'sentence-segment initial-split-visual';
            span.style.animation = `fadeIn 0.5s ease-out forwards`;
            span.style.animationDelay = `${0.5 + index * 0.15}s`;

            sentenceDisplayContainer.appendChild(span);
            sentenceDisplayContainer.appendChild(document.createTextNode(" "));
            sentenceSpanElements.push(span);
          });

          setTimeout(() => {
            sentenceSpanElements.forEach(span => span.classList.remove('initial-split-visual'));
          }, 500 + sentences.length * 150);
        } else {
          showToast('No text to synthesize.', 'warning');
          speakButton.disabled = false;
          loadingIndicator.style.display = 'none';
          return;
        }

        audioContext = new(window.AudioContext || window.webkitAudioContext)();
        const sampleRate = 24000;
        const numChannels = 1;

        audioDestinationNode = audioContext.createMediaStreamDestination();
        const speakerPlaybackNode = audioContext.createGain();
        speakerPlaybackNode.gain.value = 1;
        speakerPlaybackNode.connect(audioContext.destination);
        speakerPlaybackNode.connect(audioDestinationNode);

        mediaRecorder = new MediaRecorder(audioDestinationNode.stream, { mimeType: 'audio/ogg; codecs=opus' });

        mediaRecorder.ondataavailable = event => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          if (recordedChunks.length > 0 && recordedChunks.some(chunk => chunk.size > 0)) {
            const opusBlob = new Blob(recordedChunks, { type: 'audio/ogg; codecs=opus' });
            const opusUrl = URL.createObjectURL(opusBlob);
            downloadButtonLink.href = opusUrl;
            downloadButtonLink.style.display = 'block';
            showToast("Speech generation complete.", 'success');
          } else {
            showToast("No audio was generated to download.", 'warning');
            downloadButtonLink.style.display = 'none';
          }
          recordedChunks = [];
        };

        mediaRecorder.onerror = (event) => {
          console.error('MediaRecorder error:', event.error);
          showToast(`Error recording audio: ${event.error.name}`, 'error');
          downloadButtonLink.style.display = 'none';
        };

        mediaRecorder.start();

        let globalScheduleTime = audioContext.currentTime > 0 ? audioContext.currentTime : 0.05;
        let currentSentencePlayIndex = 0;
        let firstSentenceTimeoutId = null;
        resultsInOrder = new Array(sentences.length).fill(null); // Initialize properly

        // --- MODIFICATION: Fetching Logic Variables ---
        let activeFetchesCount = 0;
        let currentFetchQueueIndex = 0;
        // --- END MODIFICATION ---

        const fetchSentenceAttempt = async (sentence, index, retriesLeft) => {
          // Redaction is applied before calling fetchSentenceWithTimeout, which calls this.
          // spanElement is available in the caller (fetchSentenceWithTimeout) for redaction updates.
          try {
            const pcmResponse = await fetch(window.ORCHESTRATOR_WORKER_URL + '/tts', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
              body: JSON.stringify({ text: sentence.trim(), voiceId }),
            });

            if (!pcmResponse.ok) {
              const errorText = await pcmResponse.text();
              const statusInfo = `Status ${pcmResponse.status}`;
              console.error(`HTTP error for sentence ${index + 1} ("${sentence.trim()}"): ${statusInfo}, message: ${errorText}`);
              if (retriesLeft > 0 && (pcmResponse.status === 429 || pcmResponse.status >= 500)) {
                console.log(`Retrying sentence ${index + 1} (${statusInfo}), ${retriesLeft} retries left...`);
                await new Promise(resolve => setTimeout(resolve, 1000 * (3 - retriesLeft))); // Basic backoff
                return fetchSentenceAttempt(sentence, index, retriesLeft - 1);
              }
              return { error: `Fetch failed (${statusInfo})`, pcmBytes: null, sentenceText: sentence.trim(), originalIndex: index };
            }
            const pcmData = await pcmResponse.json();
            const pcmAudioContentBase64 = pcmData.audioContentBase64;

            if (!pcmAudioContentBase64) {
              console.error(`No PCM audio content received for sentence ${index + 1} ("${sentence.trim()}")`);
              return { error: `No audio for sentence ${index + 1}`, pcmBytes: null, sentenceText: sentence.trim(), originalIndex: index };
            }
            const pcmBinaryString = atob(pcmAudioContentBase64);
            const pcmLen = pcmBinaryString.length;
            const pcmBytes = new Uint8Array(pcmLen);
            for (let i = 0; i < pcmLen; i++) { pcmBytes[i] = pcmBinaryString.charCodeAt(i); }
            return { pcmBytes, error: null, sentenceText: sentence.trim(), originalIndex: index };

          } catch (e) {
            console.error(`Exception fetching/decoding sentence ${index + 1} ("${sentence.trim()}"):`, e);
            if (retriesLeft > 0) {
              console.log(`Retrying sentence ${index + 1} due to exception, ${retriesLeft} retries left...`);
              await new Promise(resolve => setTimeout(resolve, 1000 * (3 - retriesLeft)));
              return fetchSentenceAttempt(sentence, index, retriesLeft - 1);
            }
            return { error: `Exception: ${e.message}`, pcmBytes: null, sentenceText: sentence.trim(), originalIndex: index };
          }
        };

        const fetchSentenceWithTimeout = (sentence, index, retries = 2, timeoutDuration = SENTENCE_FETCH_TIMEOUT_MS) => {
          return new Promise((resolve) => { // Always resolve, never reject externally
            const spanElement = sentenceSpanElements[index];
            let timeoutHandle = setTimeout(() => {
              timeoutHandle = null; // Mark timeout as having fired
              if (spanElement) removeRedactedStyle(spanElement);
              resolve({ error: `Timeout fetching sentence ${index + 1}`, pcmBytes: null, sentenceText: sentence.trim(), originalIndex: index });
            }, timeoutDuration);

            fetchSentenceAttempt(sentence, index, retries)
              .then(result => {
                if (timeoutHandle) { // Check if timeout has NOT already fired
                  clearTimeout(timeoutHandle);
                  timeoutHandle = null;
                  if (spanElement) { // Remove redaction regardless of result.error, as the attempt is complete
                    removeRedactedStyle(spanElement);
                  }
                  resolve(result);
                }
                // If timeoutHandle is null, timeout already occurred and resolved. Do nothing more.
              })
              .catch(internalError => { // Should ideally not be hit if fetchSentenceAttempt always resolves an object
                if (timeoutHandle) {
                  clearTimeout(timeoutHandle);
                  timeoutHandle = null;
                  if (spanElement) removeRedactedStyle(spanElement);
                  console.error("Internal error from fetchSentenceAttempt's promise chain:", internalError);
                  resolve({ error: `Internal error: ${internalError.message}`, pcmBytes: null, sentenceText: sentence.trim(), originalIndex: index });
                }
              });
          });
        };


        function tryPlayNextReadySentence() {
          if (currentSentencePlayIndex >= sentences.length) {
            if (mediaRecorder && mediaRecorder.state === "recording") {
              setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                }
              }, 700);
            }
            return;
          }

          const result = resultsInOrder[currentSentencePlayIndex];
          if (result) {
            if (currentSentencePlayIndex === 0 && firstSentenceTimeoutId) {
              clearTimeout(firstSentenceTimeoutId);
              firstSentenceTimeoutId = null;
            }

            const sentenceSpan = sentenceSpanElements[currentSentencePlayIndex];
            if (result.error || !result.pcmBytes || result.pcmBytes.byteLength === 0) {
              const shortText = result.sentenceText ? result.sentenceText.substring(0, 20) + '...' : `sentence ${currentSentencePlayIndex + 1}`;
              showToast(`Skipping: "${shortText}" (Error: ${result.error || 'No audio data'})`, 'warning', 2000);
              if (sentenceSpan) {
                sentenceSpan.style.textDecoration = 'line-through wavy red';
                removeRedactedStyle(sentenceSpan); // Ensure redaction removed on failure/skip
              }
              currentSentencePlayIndex++;
              tryPlayNextReadySentence();
              return;
            }

            const { pcmBytes } = result;
            const frameCount = pcmBytes.byteLength / (2 * numChannels);
             if (frameCount === 0) {
                showToast(`Skipping: "${result.sentenceText.substring(0, 20)}..." (Empty audio data)`, 'warning', 2000);
                if (sentenceSpan) sentenceSpan.style.textDecoration = 'line-through wavy orange';
                removeRedactedStyle(sentenceSpan); // Ensure redaction removed
                currentSentencePlayIndex++;
                tryPlayNextReadySentence();
                return;
            }
            const sentenceAudioBuffer = audioContext.createBuffer(numChannels, frameCount, sampleRate);
            const nowBuffering = sentenceAudioBuffer.getChannelData(0);
            const dataView = new DataView(pcmBytes.buffer);

            for (let j = 0; j < frameCount; j++) {
              nowBuffering[j] = dataView.getInt16(j * 2, true) / 32768.0;
            }

            const source = audioContext.createBufferSource();
            source.buffer = sentenceAudioBuffer;

            if (sentenceSpan) {
              // Redaction should have been removed by fetchSentenceWithTimeout on success
              // removeRedactedStyle(sentenceSpan); // Not strictly needed here if fetchSentenceWithTimeout is robust
              const sourceScheduledStartTime = globalScheduleTime;
              const startHighlightDelay = Math.max(0, (sourceScheduledStartTime - audioContext.currentTime) * 1000);

              setTimeout(() => {
                sentenceSpanElements.forEach(sp => sp.classList.remove('playing'));
                sentenceSpan.classList.add('playing');
              }, startHighlightDelay);

              source.onended = () => {
                sentenceSpan.classList.remove('playing');
                currentSentencePlayIndex++;
                tryPlayNextReadySentence();
              };
            } else {
              source.onended = () => {
                currentSentencePlayIndex++;
                tryPlayNextReadySentence();
              };
            }

            source.connect(speakerPlaybackNode);
            if (audioContext.currentTime > globalScheduleTime) {
              globalScheduleTime = audioContext.currentTime + 0.02;
            }
            source.start(globalScheduleTime);
            globalScheduleTime += sentenceAudioBuffer.duration;
          }
        }

        // --- MODIFICATION: New function to manage fetching sentences sequentially/concurrently ---
        function manageSentenceFetching() {
          while (activeFetchesCount < currentMaxConcurrentFetches && currentFetchQueueIndex < sentences.length) {
            activeFetchesCount++;
            const sentenceToFetch = sentences[currentFetchQueueIndex];
            const originalSentenceIndex = currentFetchQueueIndex; // Closure for index
            const timeoutToUse = originalSentenceIndex === 0 ? FIRST_SENTENCE_TIMEOUT_MS : SENTENCE_FETCH_TIMEOUT_MS;
            const spanElementForFetch = sentenceSpanElements[originalSentenceIndex];

            if (spanElementForFetch) {
              applyRedactedStyle(spanElementForFetch); // Apply redaction before fetch starts
            }

            currentFetchQueueIndex++; // Increment for the next iteration/call

            fetchSentenceWithTimeout(sentenceToFetch, originalSentenceIndex, 2, timeoutToUse)
              .then(result => {
                resultsInOrder[originalSentenceIndex] = result;
                const fetchedSpanElement = sentenceSpanElements[originalSentenceIndex];

                if (result.error) {
                  if (fetchedSpanElement) {
                    fetchedSpanElement.style.textDecoration = 'line-through wavy orange'; // Indicate fetch failure
                  }
                  failureCount++;
                  consecutiveSuccessfulFetches = 0; // Reset consecutive successes on failure
                  if (failureCount >= FAILURE_TO_DECREASE && currentMaxConcurrentFetches > MIN_ALLOWED_CONCURRENCY) {
                    currentMaxConcurrentFetches = Math.max(MIN_ALLOWED_CONCURRENCY, currentMaxConcurrentFetches - 1);
                    console.log(`Concurrency decreased to: ${currentMaxConcurrentFetches}`);
                    failureCount = 0; // Reset failure count after adjustment
                  }
                  showToast(`Fetch failed for sentence ${originalSentenceIndex + 1}. Concurrency adjusted to ${currentMaxConcurrentFetches}.`, 'warning', 3000);

                } else if (result.pcmBytes && result.pcmBytes.byteLength > 0) {
                  // Successful fetch
                  consecutiveSuccessfulFetches++;
                  failureCount = 0; // Reset failures on success
                  if (consecutiveSuccessfulFetches >= CONSECUTIVE_SUCCESS_TO_INCREASE && currentMaxConcurrentFetches < MAX_ALLOWED_CONCURRENCY) {
                    currentMaxConcurrentFetches = Math.min(MAX_ALLOWED_CONCURRENCY, currentMaxConcurrentFetches + 1);
                    console.log(`Concurrency increased to: ${currentMaxConcurrentFetches}`);
                    consecutiveSuccessfulFetches = 0; // Reset consecutive successes after adjustment
                  }
                } else {
                  // No error, but no audio data (e.g., empty response)
                  if (fetchedSpanElement) {
                    fetchedSpanElement.style.textDecoration = 'line-through wavy orange'; // Indicate no audio data
                  }
                  showToast(`No audio data for sentence ${originalSentenceIndex + 1}.`, 'warning', 2000);
                }

                if (originalSentenceIndex === 0 && firstSentenceTimeoutId) {
                  clearTimeout(firstSentenceTimeoutId);
                  firstSentenceTimeoutId = null;
                  if (result && !result.error && result.pcmBytes && result.pcmBytes.byteLength > 0) {
                    if (currentSentencePlayIndex === 0) tryPlayNextReadySentence();
                  } else if (result && result.error) {
                    showToast(`First sentence failed: ${result.error || 'No audio data'}`, 'error');
                    if (currentSentencePlayIndex === 0) {
                      tryPlayNextReadySentence();
                    }
                  }
                } else if (currentSentencePlayIndex === originalSentenceIndex) {
                  tryPlayNextReadySentence();
                }

                const allResultsProcessed = resultsInOrder.every(r => r !== null);
                if (allResultsProcessed && currentSentencePlayIndex >= sentences.length) {
                  if (mediaRecorder && mediaRecorder.state === "recording") {
                    setTimeout(() => {
                      if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
                    }, 700);
                  }
                }
              })
              .catch(error => { // Should not be hit if fetchSentenceWithTimeout always resolves
                console.error(`Unhandled promise rejection for sentence ${originalSentenceIndex}:`, error);
                resultsInOrder[originalSentenceIndex] = { error: error.message || "Fetch promise rejected", pcmBytes: null, sentenceText: sentences[originalSentenceIndex], originalIndex: originalSentenceIndex };
                const errorSpanElement = sentenceSpanElements[originalSentenceIndex];
                if (errorSpanElement) {
                  removeRedactedStyle(errorSpanElement); // Ensure redaction is removed
                  errorSpanElement.style.textDecoration = 'line-through wavy red';
                }
                if (originalSentenceIndex === 0 && firstSentenceTimeoutId) {
                  clearTimeout(firstSentenceTimeoutId);
                  firstSentenceTimeoutId = null;
                  showToast(`Failed to load first sentence (promise error): ${error.message}`, 'error');
                }
                if (currentSentencePlayIndex === originalSentenceIndex) tryPlayNextReadySentence();
              })
              .finally(() => {
                activeFetchesCount--;
                manageSentenceFetching(); // Attempt to fetch the next sentence
              });
          }
        }
        // --- END MODIFICATION ---

        // MODIFICATION: Initial call to start the fetching process
        manageSentenceFetching();

        firstSentenceTimeoutId = setTimeout(() => {
          if (currentSentencePlayIndex === 0 && (!resultsInOrder[0] || (resultsInOrder[0] && (resultsInOrder[0].error || !resultsInOrder[0].pcmBytes)))) {
            const firstSentenceText = sentences.length > 0 ? (sentences[0].substring(0, 20) + '...') : "first sentence";
            showToast(`Timeout: "${firstSentenceText}" took too long.`, 'error', 5000);
            firstSentenceTimeoutId = null; // Clear the ID
            if (resultsInOrder[0] == null) { // If no result yet, mark as error
                resultsInOrder[0] = { error: `Timeout fetching sentence 1`, pcmBytes: null, sentenceText: sentences[0], originalIndex: 0 };
                const spanEl = sentenceSpanElements[0];
                if(spanEl) removeRedactedStyle(spanEl); // Ensure redaction removed
            }
            tryPlayNextReadySentence(); // Attempt to play what's available (might be the errored first sentence or next)
          }
        }, FIRST_SENTENCE_TIMEOUT_MS);

        setTimeout(() => {
            if (currentSentencePlayIndex === 0 && resultsInOrder[0] && !firstSentenceTimeoutId) { // If first sentence is ready and its specific timeout hasn't fired
                tryPlayNextReadySentence();
            }
        }, 50); // Small delay for initial kick-off if first fetch is very fast

      } catch (error) {
        console.error('General Error in speakButton listener:', error);
        showToast(`Error: ${error.message}`, 'error');
        if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
        if (audioContext && audioContext.state !== 'closed') {
          audioContext.close().catch(e => console.error("AudioContext close error in general catch:", e));
        }
      } finally {
        speakButton.disabled = false;
        loadingIndicator.style.display = 'none';
        // Failsafe for recorder stop, though specific logic should handle it earlier
        const allResultsFinalizedCheck = resultsInOrder.every(r => r !== null);
        if (allResultsFinalizedCheck && currentSentencePlayIndex >= sentences.length) {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
                }, 1000);
            }
        }
      }
    });
  </script>
</body>
</html>