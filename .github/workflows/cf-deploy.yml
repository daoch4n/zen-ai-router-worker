name: Deploy Cloudflare Workers

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, closed] # Add closed to handle cleanup
  repository_dispatch:
jobs:
  deploy:
    runs-on: ubuntu-latest
    name: Deploy
    steps:
      - uses: actions/checkout@v4
      - name: Install Wrangler
        run: npm install -g wrangler
      - name: Prepare API Key Data # Renamed and enhanced step
        id: prep_api_data
        env:
          ALL_API_KEYS_JSON_SECRET: ${{ secrets.ALL_API_KEYS_JSON }}
        run: |
          echo "Attempting to parse ALL_API_KEYS_JSON_SECRET..."
          
          # Validate and parse JSON. jq -e exits with error if parsing fails or result is empty/false.
          # jq -r '.[]' outputs each element of the JSON array on a new line.
          API_KEYS_NEWLINE_SEPARATED=$(jq -e -r '.[]' <<< "$ALL_API_KEYS_JSON_SECRET")
          JQ_EXIT_CODE=$?

          if [ $JQ_EXIT_CODE -ne 0 ]; then
            echo "Error: jq failed to parse ALL_API_KEYS_JSON_SECRET. JQ Exit Code: $JQ_EXIT_CODE" >&2
            # Attempt to print a more detailed jq validation error
            echo "Please validate the JSON structure of the ALL_API_KEYS_JSON_SECRET secret. The secret content will not be displayed." >&2
            exit 1
          fi
          
          # Populate a bash array from the newline-separated string
          mapfile -t API_KEYS_ARRAY <<< "$API_KEYS_NEWLINE_SEPARATED"
          
          local_api_keys_count=${#API_KEYS_ARRAY[@]}
          echo "Successfully parsed ${local_api_keys_count} keys."
          echo "all_api_keys_count=${local_api_keys_count}" >> $GITHUB_OUTPUT
          
          # Output the keys as a well-formed JSON array string for robust consumption by later steps
          # This handles keys with spaces or special characters correctly.
          if [ "${local_api_keys_count}" -gt 0 ]; then
            # Convert bash array elements to individual JSON strings, then collect into a JSON array
            API_KEYS_AS_JSON_ARRAY_STRING=$(printf "%s\n" "${API_KEYS_ARRAY[@]}" | jq -R . | jq -s .)
          else
            API_KEYS_AS_JSON_ARRAY_STRING="[]" # Handle empty array case
          fi
          
          # Using a delimiter for multi-line output
          echo "api_keys_as_json_array_string<<EOF_KEYS_JSON" >> $GITHUB_OUTPUT
          echo "${API_KEYS_AS_JSON_ARRAY_STRING}" >> $GITHUB_OUTPUT
          echo "EOF_KEYS_JSON" >> $GITHUB_OUTPUT

      - name: Deploy Dynamic src Workers (Production)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PASS: ${{ secrets.PASS }}
          # Pass the output from the previous step as an environment variable
          API_KEYS_JSON_FROM_OUTPUT: ${{ steps.prep_api_data.outputs.api_keys_as_json_array_string }}
        run: |
          TOTAL_KEYS=${{ steps.prep_api_data.outputs.all_api_keys_count }}
          # Use the environment variable directly. Shell quoting is simpler here.
          API_KEYS_JSON_STRING="$API_KEYS_JSON_FROM_OUTPUT"

          echo "Retrieved TOTAL_KEYS: ${TOTAL_KEYS}"
          # It's good practice to check if API_KEYS_JSON_STRING is empty, though with TOTAL_KEYS > 0 it shouldn't be.
          if [ -z "$API_KEYS_JSON_STRING" ]; then
            echo "Error: API_KEYS_JSON_FROM_OUTPUT was empty!" >&2
            exit 1
          fi

          # Read the JSON array string output back into a bash array using jq
          # This ensures keys with spaces or special characters are handled correctly.
          if ! mapfile -t API_KEYS_ARRAY < <(jq -r '.[]' <<< "$API_KEYS_JSON_STRING"); then
            echo "Error: Could not re-parse api_keys_as_json_array_string from previous step." >&2
            echo "The string content will not be displayed." >&2
            exit 1
          fi
          
          # Verify count after re-parsing (optional debug)
          if [ "${#API_KEYS_ARRAY[@]}" -ne "${TOTAL_KEYS}" ]; then
            echo "Warning: Key count mismatch after re-parsing. Expected ${TOTAL_KEYS}, got ${#API_KEYS_ARRAY[@]}." >&2
            # Depending on strictness, you might choose to exit here or proceed.
          fi
          echo "Successfully rehydrated ${#API_KEYS_ARRAY[@]} API keys for deployment."

          KEYS_PER_WORKER=8
          NUM_WORKERS=$(( (TOTAL_KEYS + KEYS_PER_WORKER - 1) / KEYS_PER_WORKER ))

          # Prepare and mask PASS secret ONCE before the loop
          ESCAPED_PASS=$(printf "%q" "${PASS}")
          echo "::add-mask::${ESCAPED_PASS}"

          # SINGLE main loop for deploying workers
          for i in $(seq 0 $((NUM_WORKERS - 1))); do
            WORKER_NAME="zen-ai-router-worker-${i}"
            START_INDEX=$((i * KEYS_PER_WORKER))
            END_INDEX=$((START_INDEX + KEYS_PER_WORKER - 1))
            
            # Initialize WORKER_VARS for this worker, starting with the prepared PASS
            WORKER_VARS="--var PASS:${ESCAPED_PASS}"

            # Calculate the actual end index for the current worker
            CURRENT_WORKER_END_INDEX=$((END_INDEX < TOTAL_KEYS ? END_INDEX : TOTAL_KEYS - 1))

            # Inner loop for assigning API keys to this worker
            for ((j=START_INDEX; j<=CURRENT_WORKER_END_INDEX; j++)); do
              # Ensure index 'j' is within the bounds of the API_KEYS_ARRAY
              if [ "${j}" -lt "${#API_KEYS_ARRAY[@]}" ] && [ -n "${API_KEYS_ARRAY[j]}" ]; then
                KEY_INDEX=$((j - START_INDEX + 1))
                ESCAPED_API_KEY=$(printf "%q" "${API_KEYS_ARRAY[j]}")
                echo "::add-mask::${ESCAPED_API_KEY}"
                WORKER_VARS="${WORKER_VARS} --var KEY${KEY_INDEX}:${ESCAPED_API_KEY}"
              fi
            done # End of inner 'for j' loop (API keys for current worker)

             wrangler deploy "src/worker.mjs" \
              --name "${WORKER_NAME}" \
              --compatibility-date "2024-05-01" \
              --compatibility-flags nodejs_compat \
              ${WORKER_VARS}
          done # This 'done' correctly closes the single main 'for i' loop (workers)
      - name: Generate Orchestrator Wrangler Config (Production)
        run: |
          # This step only needs the count, which is reliably sourced from the prep_api_data step
          TOTAL_KEYS=${{ steps.prep_api_data.outputs.all_api_keys_count }}
          KEYS_PER_WORKER=8
          NUM_WORKERS=$(( (TOTAL_KEYS + KEYS_PER_WORKER - 1) / KEYS_PER_WORKER ))

          CONFIG_CONTENT="name = \"zen-ai-router-orchestrator\"\n"
          CONFIG_CONTENT+="main = \"src/index.mjs\"\n"
          CONFIG_CONTENT+="compatibility_date = \"2024-05-01\"\n\n"

          for i in $(seq 0 $((NUM_WORKERS - 1))); do
            CONFIG_CONTENT+="[[services]]\n"
            CONFIG_CONTENT+="binding = \"BACKEND_SERVICE_${i}\"\n"
            CONFIG_CONTENT+="service = \"zen-ai-router-worker-${i}\"\n\n"
          done

          CONFIG_CONTENT+="[[durable_objects.bindings]]\n"
          CONFIG_CONTENT+="name = \"ROUTER_COUNTER\"\n"
          CONFIG_CONTENT+="class_name = \"RouterCounter\"\n\n"
          CONFIG_CONTENT+="[[migrations]]\n"
          CONFIG_CONTENT+="tag = \"v1\"\n"
          CONFIG_CONTENT+="new_sqlite_classes = [\"RouterCounter\"]\n"
          echo -e "$CONFIG_CONTENT" > orchestrator/wrangler.toml

      - name: Deploy Orchestrator Worker
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: "deploy --config orchestrator/wrangler.toml"
          vars: |
            PASS
        env:
          PASS: ${{ secrets.PASS }} # Make PASS available to the action

  deploy_preview:
    runs-on: ubuntu-latest
    name: Deploy Preview
    if: github.event.action != 'closed' # Don't deploy if the PR is closed
    steps:
      - uses: actions/checkout@v4
      - name: Install Wrangler
        run: npm install -g wrangler
      - name: Prepare API Key Data # Renamed and enhanced step
        id: prep_api_data
        env:
          ALL_API_KEYS_JSON_SECRET: ${{ secrets.ALL_API_KEYS_JSON }}
        run: |
          echo "Attempting to parse ALL_API_KEYS_JSON_SECRET..."
          
          # Validate and parse JSON. jq -e exits with error if parsing fails or result is empty/false.
          # jq -r '.[]' outputs each element of the JSON array on a new line.
          API_KEYS_NEWLINE_SEPARATED=$(jq -e -r '.[]' <<< "$ALL_API_KEYS_JSON_SECRET")
          JQ_EXIT_CODE=$?

          if [ $JQ_EXIT_CODE -ne 0 ]; then
            echo "Error: jq failed to parse ALL_API_KEYS_JSON_SECRET. JQ Exit Code: $JQ_EXIT_CODE" >&2
            # Attempt to print a more detailed jq validation error
            echo "Please validate the JSON structure of the ALL_API_KEYS_JSON_SECRET secret. The secret content will not be displayed." >&2
            exit 1
          fi
          
          # Populate a bash array from the newline-separated string
          mapfile -t API_KEYS_ARRAY <<< "$API_KEYS_NEWLINE_SEPARATED"
          
          local_api_keys_count=${#API_KEYS_ARRAY[@]}
          echo "Successfully parsed ${local_api_keys_count} keys."
          echo "all_api_keys_count=${local_api_keys_count}" >> $GITHUB_OUTPUT
          
          # Output the keys as a well-formed JSON array string for robust consumption by later steps
          # This handles keys with spaces or special characters correctly.
          if [ "${local_api_keys_count}" -gt 0 ]; then
            # Convert bash array elements to individual JSON strings, then collect into a JSON array
            API_KEYS_AS_JSON_ARRAY_STRING=$(printf "%s\n" "${API_KEYS_ARRAY[@]}" | jq -R . | jq -s .)
          else
            API_KEYS_AS_JSON_ARRAY_STRING="[]" # Handle empty array case
          fi
          
          # Using a delimiter for multi-line output
          echo "api_keys_as_json_array_string<<EOF_KEYS_JSON" >> $GITHUB_OUTPUT
          echo "${API_KEYS_AS_JSON_ARRAY_STRING}" >> $GITHUB_OUTPUT
          echo "EOF_KEYS_JSON" >> $GITHUB_OUTPUT

      - name: Deploy Single src Worker for PR Preview
        if: github.event_name == 'pull_request'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PASS: ${{ secrets.PASS }}
          # Pass the output from the previous step as an environment variable
          API_KEYS_JSON_FROM_OUTPUT: ${{ steps.prep_api_data.outputs.api_keys_as_json_array_string }}
        run: |
          TOTAL_KEYS=${{ steps.prep_api_data.outputs.all_api_keys_count }}
          # Use the environment variable directly. Shell quoting is simpler here.
          API_KEYS_JSON_STRING="$API_KEYS_JSON_FROM_OUTPUT"

          echo "Retrieved TOTAL_KEYS: ${TOTAL_KEYS}"
          # It's good practice to check if API_KEYS_JSON_STRING is empty, though with TOTAL_KEYS > 0 it shouldn't be.
          if [ -z "$API_KEYS_JSON_STRING" ]; then
            echo "Error: API_KEYS_JSON_FROM_OUTPUT was empty!" >&2
            exit 1
          fi

          # Read the JSON array string output back into a bash array using jq
          # This ensures keys with spaces or special characters are handled correctly.
          if ! mapfile -t API_KEYS_ARRAY < <(jq -r '.[]' <<< "$API_KEYS_JSON_STRING"); then
            echo "Error: Could not re-parse api_keys_as_json_array_string from previous step." >&2
            echo "The string content will not be displayed." >&2
            exit 1
          fi
          
          # Verify count after re-parsing (optional debug)
          if [ "${#API_KEYS_ARRAY[@]}" -ne "${TOTAL_KEYS}" ]; then
            echo "Warning: Key count mismatch after re-parsing. Expected ${TOTAL_KEYS}, got ${#API_KEYS_ARRAY[@]}." >&2
            # Depending on strictness, you might choose to exit here or proceed.
          fi
          echo "Successfully rehydrated ${#API_KEYS_ARRAY[@]} API keys for deployment."

          WORKER_NAME="zen-ai-router-worker-preview-${{ github.event.pull_request.number }}"
          
          ESCAPED_PASS=$(printf "%q" "${PASS}")
          echo "::add-mask::${ESCAPED_PASS}"
          
          WORKER_VARS="--var PASS:${ESCAPED_PASS}"

          CURRENT_KEY_INDEX=1
          for ((j=0; j<TOTAL_KEYS; j++)); do
            if [ "${j}" -lt "${#API_KEYS_ARRAY[@]}" ] && [ -n "${API_KEYS_ARRAY[j]}" ]; then # Ensure index is within bounds
              ESCAPED_API_KEY=$(printf "%q" "${API_KEYS_ARRAY[j]}")
              echo "::add-mask::${ESCAPED_API_KEY}"
              WORKER_VARS="${WORKER_VARS} --var KEY${CURRENT_KEY_INDEX}:${ESCAPED_API_KEY}"
              CURRENT_KEY_INDEX=$((CURRENT_KEY_INDEX + 1))
            fi
          done

           wrangler deploy "src/worker.mjs" \
            --name "${WORKER_NAME}" \
            --compatibility-date "2024-05-01" \
            --compatibility-flags nodejs_compat \
            ${WORKER_VARS}

      - name: Comment PR with Preview URL
        if: success() && github.event_name == 'pull_request' # Ensures it only runs on PR events
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const workerName = `zen-ai-router-worker-preview-${{ github.event.pull_request.number }}`;
            const previewUrl = `https://${workerName}.workers.dev`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸš€ Worker preview for PR #${context.issue.number} deployed!\n\nPreview URL: ${previewUrl}\n\nCollected API Keys Count: ${{ steps.prep_api_data.outputs.all_api_keys_count }}`
            });

  cleanup_preview:
    runs-on: ubuntu-latest
    name: Cleanup Preview Environment
    if: github.event.action == 'closed' # Run only when PR is closed
    steps:
      - uses: actions/checkout@v4 # Add checkout for access to files
      - name: Install Wrangler
        run: npm install -g wrangler
      - name: Generate PR Environment Name
        id: vars
        run: |
          # This output is used later in the workflow, but the echo itself is not needed in the logs.
          # The variable is still set for subsequent steps.
          echo "pr_environment_name=pr-${{ github.event.number }}" >> $GITHUB_OUTPUT

      - name: Prepare API Key Data for Cleanup # Renamed and enhanced step
        id: prep_api_data_cleanup
        env:
          ALL_API_KEYS_JSON_SECRET: ${{ secrets.ALL_API_KEYS_JSON }}
        run: |
          echo "Attempting to parse ALL_API_KEYS_JSON_SECRET..."
          
          # Validate and parse JSON. jq -e exits with error if parsing fails or result is empty/false.
          # jq -r '.[]' outputs each element of the JSON array on a new line.
          API_KEYS_NEWLINE_SEPARATED=$(jq -e -r '.[]' <<< "$ALL_API_KEYS_JSON_SECRET")
          JQ_EXIT_CODE=$?

          if [ $JQ_EXIT_CODE -ne 0 ]; then
            echo "Error: jq failed to parse ALL_API_KEYS_JSON_SECRET. JQ Exit Code: $JQ_EXIT_CODE" >&2
            # Attempt to print a more detailed jq validation error
            echo "Please validate the JSON structure of the ALL_API_KEYS_JSON_SECRET secret. The secret content will not be displayed." >&2
            exit 1
          fi
          
          # Populate a bash array from the newline-separated string
          mapfile -t API_KEYS_ARRAY <<< "$API_KEYS_NEWLINE_SEPARATED"
          
          local_api_keys_count=${#API_KEYS_ARRAY[@]}
          echo "Successfully parsed ${local_api_keys_count} keys."
          echo "all_api_keys_count=${local_api_keys_count}" >> $GITHUB_OUTPUT
          
          # Output the keys as a well-formed JSON array string for robust consumption by later steps
          # This handles keys with spaces or special characters correctly.
          if [ "${local_api_keys_count}" -gt 0 ]; then
            # Convert bash array elements to individual JSON strings, then collect into a JSON array
            API_KEYS_AS_JSON_ARRAY_STRING=$(printf "%s\n" "${API_KEYS_ARRAY[@]}" | jq -R . | jq -s .)
          else
            API_KEYS_AS_JSON_ARRAY_STRING="[]" # Handle empty array case
          fi
          
          # Using a delimiter for multi-line output
          echo "api_keys_as_json_array_string<<EOF_KEYS_JSON" >> $GITHUB_OUTPUT
          echo "${API_KEYS_AS_JSON_ARRAY_STRING}" >> $GITHUB_OUTPUT
          echo "EOF_KEYS_JSON" >> $GITHUB_OUTPUT

      - name: Delete Preview src Workers
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          # Pass the output from the previous step as an environment variable
          API_KEYS_JSON_FROM_OUTPUT: ${{ steps.prep_api_data_cleanup.outputs.api_keys_as_json_array_string }}
        run: |
          # Always attempt to delete the single worker deployed by the current deploy_preview job
          SINGLE_WORKER_NAME="zen-ai-router-worker-preview-${{ github.event.pull_request.number }}"
           wrangler delete --name "${SINGLE_WORKER_NAME}" --force || true
 

